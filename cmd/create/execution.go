package create

import (
	"context"
	"fmt"

	"github.com/flyteorg/flytectl/cmd/config"
	cmdCore "github.com/flyteorg/flytectl/cmd/core"
	"github.com/flyteorg/flyteidl/gen/pb-go/flyteidl/admin"
)

const (
	executionShort = "Create execution resources"
	executionLong  = `
Create the executions for given workflow/task in a project and domain.

There are three steps in generating an execution.

- Generate the execution spec file.
- Update the inputs for the execution if needed.
- Run the execution by passing in the generated yaml file.

The spec file should be generated first and then run the execution using the spec file.
This would use the latest version of the task core.advanced.run_merge_sort.merge if version flag is not passed.
Notice the source and target domain/projects can be different.

::

 bin/flytectl create execution  --sourceDomain development  --sourceProject flytectldemo --targetDomain development --targetProject flytesnacks --task core.advanced.run_merge_sort.merge   --genExecSpecFile

The generated file would look similar to this

.. code-block:: yaml

	 genExecSpecFile: true
	 iamRoleURN: 'example: arn:aws:iam::12345678:role/defaultrole'
	 inputs:
	   sorted_list1:
	   - 0
	   sorted_list2:
	   - 0
	 kubeServiceAcct: ""
	 sourceDomain: development
	 sourceProject: flytectldemo
	 targetDomain: development
	 targetProject: flytectldemo
	 task: core.advanced.run_merge_sort.merge
	 version: ""


The generated file can be modified to change the input values.

.. code-block:: yaml

	 genExecSpecFile: true
	 iamRoleURN: 'example: arn:aws:iam::12345678:role/defaultrole'
	 inputs:
	   sorted_list1:
	   - 2
	   - 4
	   - 6
	   sorted_list2:
	   - 1
	   - 3
	   - 5
	 kubeServiceAcct: ""
	 sourceDomain: development
	 sourceProject: flytectldemo
	 targetDomain: development
	 targetProject: flytectldemo
	 task: core.advanced.run_merge_sort.merge
	 version: ""

And then can be passed through the command line.

::

 bin/flytectl create execution --file core.advanced.run_merge_sort.merge.execution_spec.yaml

Usage
`
)

//go:generate pflags ExecutionConfig --default-var executionConfig

// ExecutionConfig hold configuration for create execution flags and configuration of the actual task or workflow  to be launched.
type ExecutionConfig struct {
	// pflag section
	File            string `json:"file,omitempty" pflag:",file for the execution params.If not specified defaults to <<workflow/task>_name>.execution_spec.yaml"`
	TargetDomain    string `json:"targetDomain" pflag:",project where execution needs to be created.If not specified configured domain would be used."`
	TargetProject   string `json:"targetProject" pflag:",project where execution needs to be created.If not specified configured project would be used."`
	KubeServiceAcct string `json:"kubeServiceAcct" pflag:",kubernetes service account AuthRole for launching execution."`
	IamRoleARN      string `json:"iamRoleARN" pflag:",iam role ARN AuthRole for launching execution."`
	// Non plfag section is read from the execution config generated by get task/launchplan
	Workflow string                 `json:"workflow,omitempty"`
	Task     string                 `json:"task,omitempty"`
	Version  string                 `json:"version"`
	Inputs   map[string]interface{} `json:"inputs"`
}

type ExecutionParams struct {
	name   string
	isTask bool
}

var (
	executionConfig = &ExecutionConfig{}
)

func createExecutionCommand(ctx context.Context, args []string, cmdCtx cmdCore.CommandContext) error {
	var execParams *ExecutionParams
	var err error
	sourceProject := config.GetConfig().Project
	sourceDomain := config.GetConfig().Domain
	if execParams, err = readConfigAndValidate(); err != nil {
		return err
	}
	var executionRequest *admin.ExecutionCreateRequest
	if execParams.isTask {
		if executionRequest, err = createExecutionRequestForTask(ctx, execParams.name, sourceProject, sourceDomain, cmdCtx); err != nil {
			return err
		}
	} else {
		if executionRequest, err = createExecutionRequestForWorkflow(ctx, execParams.name, sourceProject, sourceDomain, cmdCtx); err != nil {
			return err
		}
	}
	exec, _err := cmdCtx.AdminClient().CreateExecution(ctx, executionRequest)
	if _err != nil {
		return _err
	}
	fmt.Printf("execution identifier %v\n", exec.Id)
	return nil
}
